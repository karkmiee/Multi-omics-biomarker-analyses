###Title: Weighted correlation network analysis (WGCNA) of circulating metabolites.

#The WGCNA R package builds “weighted gene correlation networks for analysis” from expression data.
#Note: Metabolomics data is not expression data, however, this analyzing method has been used in the research field to study metabolites that correlate with one and other.
#https://bioinformaticsworkbook.org/tutorials/wgcna.html#gsc.tab=0

##Here we studied how c-Metab co-level modules associate with path_MMR variant or upcoming cancer of LS carriers
#Data: NMR analyzed serum metabolite content

#Abbreviations used in data and scripts:
#LS = lynch syndrome group, MMR gene mutation carriers
#c-Metab = circulating metabolites


#-------------------------------------------------------------------------------
##Step 1: Install needed packages and import dataframes


library(tidyverse)     
library(magrittr)      # provides the %>% operator
library(WGCNA)
library(GO.db)

#Load data normalized c-Metab data and phenodata
mets <- read.table("boxcox_transf_data.txt")
metadata <-read.table("phenoData_filtered.txt", header= TRUE,sep="\t")

#-------------------------------------------------------------------------------
##Step 2. Pick soft threshold for WGCNA:

#when you pick up soft threshold it should only contain metabolite levels


#We can see now that the rows = samples and columns = c-Metab probes. We’re ready to start WGCNA. 
#A correlation network will be a complete network (all c-Metab are connected to all other c-Metab). 
#Ergo we will need to pick a threshhold value (if correlation is below threshold, remove the edge). We assume the true biological network follows a scale-free structure (see papers by Albert Barabasi).

#To do that, WGCNA will try a range of soft thresholds and create a diagnostic plot: 


allowWGCNAThreads() #optional, allows few threads

# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to = 20, by = 2))

# Call the network topology analysis function
sft = pickSoftThreshold(
  mets,       #input data     
  powerVector = powers,
  verbose = 5
)

par(mfrow = c(1,2));
cex1 = 0.9;

plot(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     xlab = "Soft Threshold (power)",
     ylab = "Scale Free Topology Model Fit, signed R^2",
     main = paste("Scale independence")
)
text(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     labels = powers, cex = cex1, col = "red"
)
abline(h = 0.90, col = "red")
plot(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     xlab = "Soft Threshold (power)",
     ylab = "Mean Connectivity",
     type = "n",
     main = paste("Mean connectivity")
)
text(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     labels = powers,
     cex = cex1, col = "red")

#Read me: The Scale-Free Topology Model Fit (signed R^2) plot generated by pickSoftThreshold in WGCNA is used to assess the goodness of fit of the network to a scale-free topology under different soft-thresholding powers. 
#Ideally, you want to choose a soft-thresholding power at which the model fit (R^2) is high and the curve reaches a plateau, indicating that the network follows a scale-free topology.

#If your Scale-Free Topology Model Fit plot shows a scattered or irregular pattern with data points all over the place instead of forming a smooth curve, it may indicate that the data does not exhibit a clear scale-free network structure across the tested soft-thresholding powers.
#In such cases, you might face challenges in selecting an appropriate soft-thresholding power. Here are a few things you can consider:

#1. Evaluate the Highest Soft Threshold Before Irregularities:
#Examine the plot for the highest soft-thresholding powers before the irregularities occur. 
#Choose a power that is just before the point where the curve becomes unstable.

#2. Inspect the Connectivity and Module Detection:
#Proceed with the analysis using the chosen soft-thresholding power, and then inspect the connectivity and module detection results. 
#Even if the curve is not ideal, the resulting network may still provide meaningful insights.

#3. Consider Alternative Methods:
#If the scale-free topology fit is challenging to achieve, you might also consider alternative methods for network analysis or explore different soft-thresholding power selection strategies.

#4. Choose the Highest Possible Power: Even if your data don't reach the recommended threshold, you can still choose the highest power where the scale-free topology fit index (R^2) starts to level off or at least stabilize. 
#This power should represent the point where the network starts to exhibit scale-free properties. 
#While it might not be perfect, it's often the best compromise when the curve doesn't reach the desired threshold.


#The choice of the soft-thresholding power (β) in WGCNA is crucial as it determines the scale of the co-expression network. 
#Selecting too high or too low a soft-thresholding power can have significant effects on the resulting network and subsequent analyses.
#Based on plots the appropriate soft thresholds are: 9-->. Also higher values could work. 
#------------------------------------------------------------------
##Step 3. WGCNA
picked_power = 9     #with whole data picked power 9 
temp_cor <- cor       
cor <- WGCNA::cor         
netwk <- blockwiseModules(mets,                # <= input here
                          
                          # == Adjacency Function ==
                          power = picked_power,                # <= power here
                          networkType = "signed",              #allows positive and negative correlations
                          
                          # == Tree and Block Options ==
                          deepSplit = 2,
                          pamRespectsDendro = F,
                          # detectCutHeight = 0.75,
                          minModuleSize = 5,  #test different module sizes
                          maxBlockSize = 170,
                          
                          # == Module Adjustments ==
                          reassignThreshold = 0,
                          mergeCutHeight = 0.25,
                          
                          # == TOM == Archive the run results in TOM file (saves time)
                          saveTOMs = T,
                          saveTOMFileBase = "ER",
                          
                          # == Output Options
                          numericLabels = T,
                          verbose = 3)
cor <- temp_cor     # Return cor function to original namespace

# Convert labels to colors for plotting
mergedColors = labels2colors(netwk$colors)
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )

#netwk$colors[netwk$blockGenes[[1]]]
#table(netwk$colors)

##------------------------------------------------------------------------------
##Step 4. Module-trait associations.

#We have written out a tab delimited file listing the c-Metab and their modules. 
#However, we need to figure out which modules are associated with each trait of interest. 
#WGCNA will calcuate an Eigangene (hypothetical central gene) for each module, so it easier to determine if modules are associated with different traits.

# Load required libraries
library(dplyr)
library(tidyr)
library(ggplot2)

module_df <- data.frame(
  gene_id = names(netwk$colors),
  colors = labels2colors(netwk$colors)
)

write_delim(module_df,
            file = "gene_modules_mets.txt",
            delim = "\t")

# Get Module Eigengenes per cluster
MEs0 <- moduleEigengenes(mets, mergedColors)$eigengenes

# Reorder modules so similar modules are next to each other
MEs0 <- orderMEs(MEs0)
module_order = names(MEs0) %>% gsub("ME","", .)


#Create vector from phenodata
Variant <- metadata$Variant
status <- metadata$status

# Combine vectors with module eigengenes dataframe
combined_data <- cbind(Variant, MEs0)
combined_data <- cbind(status, MEs0)

# Delete rows where Variant is "PMS2" when assessing variant differences
#combined_data <- combined_data[combined_data$Variant != "PMS2", ]

#Repeat group comparison tests for each module.

# Perform Tukey's HSD test
tukey_result <- TukeyHSD(aov(MEturquoise ~ Variant, data = combined_data))
print(tukey_result) # Print the results

#Use T-test to compare Future Cancer and Healthy groups
t_test <- t.test(MEyellow ~ status, data = combined_data)
print(t_test)


#-------------------------------------------------------------------------------
# Step 5. Construct the Linear Mixed-Effects Model (LMM)

#https://www.nature.com/articles/s41598-017-18705-z
#https://www.geeksforgeeks.org/how-linear-mixed-model-works-in-r/
#https://gkhajduk.github.io/2017-03-09-mixed-models/

#A linear mixed model (LMM), also known as a mixed-effects model or hierarchical linear model, extends the capabilities of simple linear regression by accounting for both fixed and random effects in the analysis. 
#Here's what each component of a linear mixed model does:

#Fixed Effects: These are similar to the coefficients in a simple linear regression model. 
#They represent the average effect of predictor variables on the response variable across all levels of the random effects. 
#Fixed effects are typically the primary focus of inference in the model.

#Random Effects: These capture variability that is not explained by the fixed effects. 
#Random effects are often used to account for correlations or dependencies within the data, such as repeated measures on the same subjects or clustering of observations within groups. 
#Random effects are assumed to be drawn from a distribution with a mean of zero.


library(lme4)  # For linear mixed-effects modeling

#add random effects and fixed effect to df
Age <- metadata$Age
BMI <- metadata$BMI
combined_data <- cbind(Age, MEs0)
combined_data <- cbind(Variant, combined_data)
combined_data <- cbind(BMI, combined_data)

# Replace commas with dots in the specified column
combined_data$Age <- gsub(",", ".", combined_data$Age)
combined_data$Age <- as.numeric(combined_data$Age) #convert numeric
combined_data$BMI <- gsub(",", ".", combined_data$BMI)
combined_data$BMI <- as.numeric(combined_data$BMI)
combined_data <- combined_data[combined_data$Variant != "PMS2", ]

## Define the LMM equation: 

#MEturquoise
model_turquoise <- lmer(MEturquoise ~ Variant + (1 | Age) + (1 | BMI),
                   data = combined_data)
summary(model_turquoise)
full.lmer <- lmer(MEturquoise ~ Variant + (1 | Age) + (1 | BMI),
                  data = combined_data, REML = FALSE)
reduced.lmer <- lmer(MEturquoise ~ 1 + (1 | Age) + (1 | BMI),
                     data = combined_data, REML = FALSE)
anova(reduced.lmer, full.lmer)


#install.packages('stargazer')
library(stargazer)

model_turquoise_star <- stargazer(model_turquoise, type = "text",
                  digits = 3,
                  star.cutoffs = c(0.05, 0.01, 0.001),
                  digit.separator = "")


# Extract t-values, standard errors, and variable names from the model summary
t_values <- summary(model_turquoise)$coefficients[, "t value"]
standard_errors <- summary(model_turquoise)$coefficients[, "Std. Error"]
variables <- rownames(summary(model_turquoise)$coefficients)

# Create a data frame
df <- data.frame(Variant = variables, t_value = t_values, std_error = standard_errors)

# Replace "Intercept" with "VariantMLH1" in the "Variant" column
df$Variant[df$Variant == "(Intercept)"] <- "VariantMLH1"


# Plot heatmap using ggplot2
library(ggplot2)

ggplot(data = df, aes(x = "", y = factor(Variant), fill = t_value)) +
  geom_tile() +
  geom_text(aes(label = paste(round(t_value, 2), "\n(", round(std_error, 2), ")")), size = 3) +
  scale_fill_gradient(low = "turquoise", high = "violet") +
  labs(title = "Linear Mixed Model",
       x = "Module_Turquoise",
       y = "",
       fill = "t-value") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))


##------------------------------------------------------------------------------

