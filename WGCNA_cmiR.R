###Title: Weighted correlation network analysis (WGCNA) of circulating microRNAs.

#The WGCNA R package builds “weighted gene correlation networks for analysis” from expression data
#https://bioinformaticsworkbook.org/tutorials/wgcna.html#gsc.tab=0

#Data: Next generation sequencing serum miRNA content

#Abbreviations used in data and scripts:
#LS = lynch syndrome group, MMR gene mutation carriers
##Circulating microRNA = cmiR


#-------------------------------------------------------------------------------
##Step 1: Install packages and import dataframes: LS phenodata and normalized cmiRs.

library(tidyverse) 
library(magrittr)      # provides the %>% operator
library(WGCNA)
library(GO.db)
library(impute)
library(preprocessCore)

#Load data normalized cmiR countdata and phenodata
cmiR1 <- read.table("normalized_miR_counts.txt")
metadata <-read.table("phenoData_filtered.txt", header= TRUE,sep="\t")

# Transpose the dataframe
cmiR <- as.data.frame(t(cmiR1))  #use in module detection

#-------------------------------------------------------------------------------
##Step 2. Pick soft threshold for WGCNA:

#When you pick up soft threshold it should only contain expression values


#We can see now that the rows = samples and columns = miR probes. We’re ready to start WGCNA. 
#A correlation network will be a complete network (all genes are connected to all other genes). 
#Ergo we will need to pick a threshhold value (if correlation is below threshold, remove the edge). 
#We assume the true biological network follows a scale-free structure (see papers by Albert Barabasi).

#To do that, WGCNA will try a range of soft thresholds and create a diagnostic plot: 


allowWGCNAThreads() #optional, allows few threads

# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to = 20, by = 2))

# Call the network topology analysis function
sft = pickSoftThreshold(
  cmiR,            
  powerVector = powers,
  verbose = 5
)

par(mfrow = c(1,2));
cex1 = 0.9;

plot(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     xlab = "Soft Threshold (power)",
     ylab = "Scale Free Topology Model Fit, signed R^2",
     main = paste("Scale independence")
)
text(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     labels = powers, cex = cex1, col = "red"
)
abline(h = 0.90, col = "red")
plot(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     xlab = "Soft Threshold (power)",
     ylab = "Mean Connectivity",
     type = "n",
     main = paste("Mean connectivity")
)
text(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     labels = powers,
     cex = cex1, col = "red")

#Read me: The Scale-Free Topology Model Fit (signed R^2) plot generated by pickSoftThreshold in WGCNA is used to assess the goodness of fit of the network to a scale-free topology under different soft-thresholding powers. 
#Ideally, you want to choose a soft-thresholding power at which the model fit (R^2) is high and the curve reaches a plateau, indicating that the network follows a scale-free topology.

#If your Scale-Free Topology Model Fit plot shows a scattered or irregular pattern with data points all over the place instead of forming a smooth curve, it may indicate that the data does not exhibit a clear scale-free network structure across the tested soft-thresholding powers.
#In such cases, you might face challenges in selecting an appropriate soft-thresholding power. Here are a few things you can consider:

#1. Evaluate the Highest Soft Threshold Before Irregularities:
    #Examine the plot for the highest soft-thresholding powers before the irregularities occur. 
    #Choose a power that is just before the point where the curve becomes unstable.

#2. Inspect the Connectivity and Module Detection:
    #Proceed with the analysis using the chosen soft-thresholding power, and then inspect the connectivity and module detection results. 
    #Even if the curve is not ideal, the resulting network may still provide meaningful insights.

#3. Consider Alternative Methods:
    #If the scale-free topology fit is challenging to achieve, you might also consider alternative methods for network analysis or explore different soft-thresholding power selection strategies.

#The choice of the soft-thresholding power (β) in WGCNA is crucial as it determines the scale of the co-expression network. 
#Selecting too high or too low a soft-thresholding power can have significant effects on the resulting network and subsequent analyses.
#based on plots the appropriate soft thresholds are: 5, 6 or 7. Here we select a soft-thresholding power 6. 
#-------------------------------------------------------------------------------
##Step 3. WGCNA

#Note here we select to use Spearman correlation instead of Pearson correlation. 
#This is due to some variability in cmiR expression data, where even after normalization, all cmiRs did not follow normal distribution.
#Second note: We tested also Pearson correlation and results were quite similar. 

picked_power = 6     
temp_cor <- cor      
cor <- function(...) WGCNA::cor(method = "spearman", ...)         # Force it to use WGCNA cor function (fix a namespace conflict issue)
netwk <- blockwiseModules(cmiR,                # <= input here
                          
                          # == Adjacency Function ==
                          power = picked_power,                # <= power here
                          networkType = "signed",              #allows positive and negative correlations
                          
                          # == Tree and Block Options ==
                          deepSplit = 2,
                          pamRespectsDendro = F,
                          # detectCutHeight = 0.75,
                          minModuleSize = 5,
                          maxBlockSize = 317, 
                          
                          # == Module Adjustments ==
                          reassignThreshold = 0,
                          mergeCutHeight = 0.25,
                          
                          # == TOM == Archive the run results in TOM file (saves time)
                          saveTOMs = T,
                          saveTOMFileBase = "ER",
                          
                          # == Output Options
                          numericLabels = T,
                          verbose = 3)
cor <- temp_cor     # Return cor function to original namespace

# Convert labels to colors for plotting
mergedColors = labels2colors(netwk$colors)
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )

#netwk$colors[netwk$blockGenes[[1]]]
#table(netwk$colors)

##------------------------------------------------------------------------------
##Step 4. Module-trait associations.

#We have written out a tab delimited file listing the cmiRs and their modules. 
#However, we need to figure out which modules are associated with each variant group or status. 
#WGCNA will calcuate an Eigangene (hypothetical central gene) for each module, so it easier to determine if modules are associated with different path_MMR genes or Future cancer/Healthy groups.

# Load required libraries
library(dplyr)
library(tidyr)
library(ggplot2)

module_df <- data.frame(
  gene_id = names(netwk$colors),
  colors = labels2colors(netwk$colors)
)

write_delim(module_df,
            file = "gene_modules_cmiR.txt",
            delim = "\t")


# Get Module Eigengenes per cluster
MEs0 <- moduleEigengenes(cmiR, mergedColors)$eigengenes

# Reorder modules so similar modules are next to each other
MEs0 <- orderMEs(MEs0)
module_order = names(MEs0) %>% gsub("ME","", .)


#create vector from traits of interest
Variant <- metadata$Variant
status <- metadata$Status


# Combine trait of interest vectors with module eigengene data frame
#Note: make sure the sample order is same in both dfs
combined_data <- cbind(Variant, MEs0)
combined_data <- cbind(status, MEs0)

# Delete rows where Variant is "PMS2" when assessing variant differences
#combined_data <- combined_data[combined_data$Variant != "PMS2", ]

#Repeat group comparison tests for each module.

# Perform Tukey's HSD test to compare Variant groups
tukey_result <- TukeyHSD(aov(MEpink ~ Variant, data = combined_data))
print(tukey_result) # Print the results

#Use T-test to compare Future Cancer and Healthy groups
t_test <- t.test(MEpurple ~ status, data = combined_data)
print(t_test)


#-------------------------------------------------------------------------------
#Step 5. Visualize the group differences. 

# Box plot

# Ensure 'future_ca' is a factor with two levels
combined_data$future_ca <- factor(combined_data$status, levels = c("Healthy", "Future cancer"))

# Define colors to match the example plot
healthy_color <- "#F8766D"   # Coral red for Healthy
future_cancer_color <- "#00BFC4"   # Teal for Future Cancer


# Plot with matching colors
ggplot(combined_data, aes(x = future_ca, y = MEpink, fill = status)) +
  geom_boxplot() +
  scale_fill_manual(values = c("Healthy" = healthy_color, "Future cancer" = future_cancer_color)) +
  labs(title = "MEpink Distribution by Status", x = "Status", y = "MEpink") +
  theme(
    panel.background = element_rect(fill = "white"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
 
###-----------------------------------------------------------------------------

